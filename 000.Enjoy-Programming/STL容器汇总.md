###综述
容器类是C++编程的一大特色。容器的加入使得编程的效率得到了极大的提升。  
在C++中，用到的容器可以分为以下几类：  
#####顺序类容器  
`vector（数组）`  
`deque（双向队列）`  
`list（双向链表）`  
#####容器适配器  
`stack（栈）`  
`queue（队列）`  
`priority_queue（优先队列）`  
#####关联类容器  
`set/multiset（集合）`  
`map/multimap（映射）`  
`unordered_set/unordered_multiset（无序集合）`  
`unordered_map/unordered_multimap（无序映射）`  

----

###实现原理
C++里有那么多容器，它们到底是怎么实现的呢？
#####vector  
`vector类似于数组，但是可以不预先定义大小，加入元素时会自动扩展大小。`  
`扩展大小的步骤：申请更大的内存>将数据拷贝到新内存>销毁原来的对象>释放原来的内存。`   
`每次对vector扩容时增加当前容量的50%。`  
`基本操作：队尾的push_back()和pop_back()，随机访问[]。`  
`特点：队尾操作效率高。中间插入删除效率低。随机访问效率高。`
#####deque
`deque是对vector的扩展，采用多个连续的内存块首尾相连。`  
`扩容时开辟一个新空间，然后链接在一起，不需要将原来的内容重新拷贝。`  
`使用一个map来控制各个块之间链接关系，对map扩容时类似vector扩容。`  
`基本操作：头尾的push_front()，pop_front()，push_back()，pop_back()，随机访问[]。`  
`特点：头尾都能操作，且效率都很高。内部操作效率一般。随机访问效率较高。`
#####list
`list把deque的各个块继续细分，使得每个块只有一个元素，即成了一个双向的链表。`  
`特点：插入删除效率高。不支持随机访问。`
#####stack
`容器适配器本身并不是一个容器，而是调用其他容器的接口实现。`  
`stack需要的操作有pop()，push()，top()三个，都是在尾部进行操作，从原理上看使用vector、deque、list都能方便地实现stack。`  
`事实上，容器适配器是可以指定底层实现容器的类型的，不过为了和queue统一，默认采用deque实现。`  
#####queue
`queue需要的操作有队首pop()，队尾push()，front()，back()四个，通过deque实现最方便，也能通过list实现。`  
#####priority_queue
`priority_queue和queue看起来很像，但实质上是不同的。`     
`priority_queue每次出列的是值最大的数。因此每一次push后必须对队列进行排序，找出最大的值。`     
`事实上，我们每次只需要找到最大的值，而并不需要完全对队列进行排序，使用最大堆来实现最合理不过了。`    
`最大堆本身是用数组实现的，因此对于priority_queue，选用vector作为底层容器来实现。`     
#####set/multiset
`一组元素的集合。有没有multi的区别就是集合里的元素唯不唯一。`     
`set内部是基于红黑树实现的（红黑树是一棵排序二叉树），因此set内部是排序的。对set进行遍历输出就能发现了。`     
#####map/multimap
`一组映射（key-value）的集合。有没有multi的区别就是集合里的key唯不唯一。`     
`map内部是基于红黑树实现的（红黑树是一棵排序二叉树），因此map内部是根据key排序的。对map进行遍历输出就能发现了。`    
`map中可以使用[key]操作来对元素进行读写操作`
#####unordered_set/unordered_multiset
`类似于set，只不过其内部是不排序的。有没有multi的区别就是集合里的元素唯不唯一`     
`unordered_set内部是基于哈希表实现的，并了获得更快的读写速度而牺牲了有序的特性。`   
#####unordered_map/unordered_multimap
`类似于map，只不过其内部是不排序的。有没有multi的区别就是集合里的key唯不唯一`     
`unordered_map内部是基于哈希表实现的，并了获得更快的读写速度而牺牲了有序的特性。`   
`map中可以使用[key]操作来对元素进行读写操作`

----

###容器选用
什么时候应该用什么样的容器？只要知道了各个容器的实现原理，这个问题也就迎刃而解了。  
#####stack、queue
`这个选择最简单，看先进先出还是先进后出。`  
`选用stack和queue的时候必须要清楚，不能使用下标来直接获得元素。`
#####vector、deque、list
`如果需要使用下标来获取元素，那就不能使用stack和queue了，此时根据题目的特点来选取容器了。`   
`vector最常用，下标读取快，队尾插入删除快，但是如果在中间大量的插入删除，效率就会非常慢。`   
`list最适合链表题，各处插入删除都快，但是不能直接获取特定位置的值。`   
`queue最适合头尾都有操作的时候，下标读取也非常快，中间插入也不是很慢，是对vector和list的一个折中方案。`   
#####set、map
`如果仅仅需要保存元素，那就用set。如果元素对应了另一个值，就选用map吧。`     
`set经常用于判断一个值是不是唯一或者第一次出现。`   
`map的用处就非常广泛了，key-value式的存储在很多地方都会用到。`    
#####map、unordered_map
`其实就是红黑树和哈希表的区别。`     
`红黑树有序，但是每次操作都是logn的复杂度。`  
`哈希表无序，但是每次操作理论上只需要1的复杂度。（如果散列情况糟糕的话，复杂度也是相当高的）` 

----

###可用操作
除了最基本的读取数据外，容器类还封装了一些常用的方法。方法很多，只列举了几个常用的。
#####迭代器iterator
`除了容器适配器以为，其他容器都支持迭代器。`    
`使用迭代器可以按照元素在内存中的顺序一个一个进行读取。因此内部是否有序根据迭代器操作就是知道。`    
`迭代器书写类型名非常长，其实在C++中是直接可以用auto类型代替的。这样可以大大简化书写。（不知道会不会减慢效率）`
######常用操作
`size()数量（适用于全部容器）`   
`empty()判断是否为空（适用于全部容器）`   
`sort()排序（适用于顺序容器，list比较特殊）`   
`find()寻找`   
`count()计数`   
`insert()插入`   
`erase()删除`   
