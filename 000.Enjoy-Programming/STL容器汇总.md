###综述
容器类是C++编程的一大特色。容器的加入使得编程的效率得到了极大的提升。  
在C++中，用到的容器可以分为以下几类：  
#####顺序类容器  
`vector（数组）`  
`deque（双向队列）`  
`list（双向链表）`  
#####容器适配器  
`stack（栈）`  
`queue（队列）`  
`priority_queue（优先队列）`  
#####关联类容器  
`set/multiset（集合）`  
`map/multimap（映射）`  
`unordered_set/unordered_multiset（无序集合）`  
`unordered_map/unordered_multimap（无序映射）`  

----

###实现原理及适应情况分析
什么时候应该用什么样的容器？只要知道了各个容器的实现原理，这个问题也就迎刃而解了。  
#####vector  
`vector类似于数组，但是可以不预先定义大小，加入元素时会自动扩展大小。`  
`扩展大小的步骤：申请更大的内存>将数据拷贝到新内存>销毁原来的对象>释放原来的内存。`   
`每次对vector扩容时增加当前容量的50%。`  
`基本操作：队尾的push_back()和pop_back()，随机访问[]。`  
`特点：队尾操作效率高。中间插入删除效率低。随机访问效率高。`
#####deque
`deque是对vector的扩展，采用多个连续的内存块首尾相连。`  
`扩容时开辟一个新空间，然后链接在一起，不需要将原来的内容重新拷贝。`  
`使用一个map来控制各个块之间链接关系，对map扩容时类似vector扩容。`  
`基本操作：头尾的push_front()，pop_front()，push_back()，pop_back()，随机访问[]。`  
`特点：头尾都能操作，且效率都很高。内部操作效率一般。随机访问效率较高。`
#####list
`list把deque的各个块继续细分，使得每个块只有一个元素，即成了一个双向的链表。`  
`特点：插入删除效率高。不支持随机访问。`
#####stack
`容器适配器本身并不是一个容器，而是调用其他容器的接口实现。`  
`stack需要的操作有pop()，push()，top()三个，都是在尾部进行操作，从原理上看使用vector、deque、list都能方便地实现stack。`  
`事实上，容器适配器是可以指定底层实现容器的类型的，不过为了和queue统一，默认采用deque实现。`  
#####queue
`queue需要的操作有队首pop()，队尾push()，front()，back()四个，通过deque实现最方便，也能通过list实现。`  
#####priority_queue
`priority_queue和queue看起来很像，但实质上是不同的。`  
`priority_queue每次出列的是值最大的数。因此每一次push后必须对队列进行排序，找出最大的值。`  
`事实上，我们每次只需要找到最大的值，而并不需要完全对队列进行排序，使用最大堆来实现最合理不过了。`   `最大堆本身是用数组实现的，因此对于priority_queue，选用vector作为底层容器来实现。`  
